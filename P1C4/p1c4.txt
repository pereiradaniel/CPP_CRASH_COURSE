Using try-catch Blocks

    Used to establish exception handlers for a block of code.

    Within the try block:
        Place code that might throw an exception.

    Within the catch block:
        Specify a handler for each exception type you can handle.

        Example: throw_exception.cpp


INHERITANCE

    Understanding that sub-classes can inherit the functionality of their super-classes, is essential before learning about the stdlib exceptions.

EXAMPLE:

    ```
    struct Superclass {
        int x;
    };

    struct Subclass : Superclass {
        // Inherits members from Superclass that are not marked private!
        int y;
        int foo() {
            return x + y; // Subclass inherits int x from Superclass!
        }
    };

    ```

    Handlers will catch a given type and any of its childrens' types.


stdlib Exception Classes

    Inheritance has crucial impact on how code handles exceptions.

    stdlib contais useful exception types readily available to be used.


Standard Exception Classes

    <stdexcept> header

    std::exception is the superclass for all the sandard exception classes.

    Three main groups of subclasses in std::exception:

        1. logic errors     <- Will encounter!
        2. runtime errors   <- Will encounter!
        3. language support errors (not that relevant)

---------------------------- 
exception:
    runtime_error:
        system-error,
        underflow_error,
        overflow_error,
        ...
    logic_error:
        domain_error,
        invalid-argument,
        length_error,
        out_of_range,
        ...
bad_cast,
bad_alloc,
...
---------------------------- 

Logic errors

    Derive from the logic_error class.
    Can be avoided through careful programming.

    Subclasses to be aware of:

        domain_error
        Errors related to valid input range.

        invalid_argument
        Unexpected arguments.

        length_error
        Some action violates the maximum size constraint.

        out_of_range
        Some value is not within expected range.


Runtime Errors

    Derive from the runtime_error class.
    Help to report error conditions outside the program's scope.

    Subclasses to be aware of:

        system_error
        Operating system has encountered some error.

        over_flow and under_flow
        Arithmetic overflow and underflow.


Other Errors

    Inherit directly from exception.

        bad_alloc
        Keyword new failed to allocate required memory for dynamic storage.


Language Support Errors

    Indicate that some core language feature failed at runtime.
    Programmers do not use these errors directly.


Handling exceptions

    Rules for handling exceptioons are based on class inheritance.
    A catch block can handle a thrown exception if the type matches the handler's exception type, or if the thrown type *inherits* from the handler's type.

    EXAMPLE:
    Handling different types of exceptions originating from the same try block:

    ```
    try {
        // Code that might throw an exception.
    } catch (const std::logic_error& ex) {
        // Log exception and terminate the program: Programming error.
    } catch (const std::runtime_error& ex) {
        // Try to recover.
    } catch (const std::exception& ex) {
        // Handle any exception deriving from std:exception that is not a logic_error or runtime_error.
    } catch(...) {
        // Unforseen exception type has been thrown.
    }

    ```


RETHROWING AN Exception

    Within a catch block the throw keyword can be used: This is called rethrowing an exception.

    ```
    try {
            // Code that might throw a system_error.

    } catch(const std::system_error& ex) {
        if (ex.code()! = std::errc::permission_denied) {
            // Not a permission denied error!
            throw;  // Rethrow if not an EACCES error.
        }
        // Recover from permission denied.
    }

    ```

    There are performance penalties to using this convoluted code!
    
    Define a new exception type and create a separate catch handler for the EACCES error:

    ```
    try {
            // Throw a PermissionDenied instead
    } catch(const PermissionDenied& ex) {
        // Recover from an EACCES error (Permission Denied) ...
    }

    ```


User-Defined Exceptions

    Your own exceptions can be defined.
    They will usually inherit from std::exception.
    All the classes from stdlib use exceptions that derive from std::exception.


The noexcept Keyword

    Any function that cannot possibly throw an exception can and should be marked as noexcept.

    ```
    bool is_odd(int x) noexcept {
        return 1 == (x % 2);
    }

    ```

    What happens when an exception is thrown within a block marked 'noexcept':
    Program will crash if your code throws an exception inside a function marked noexcept!

    Functions marked noexcept will enable some code optimizations. The compiler can use move semantics.

    -=[ CAUTION ]=-

        Be extremely careful when you mark your own functions noexcept. If your program throws an exception inside a 'noexcept' functin, the C++ runtime cllas the functin std::terminate that will exit the program via abort. The prgogram cannot recover!

Call Stacks and Exceptions

    The 'call stack' is a runtime structure that stores information about active functions.
    Allows programs to have many function calls nested within each other.

Stacks

    A stack is a flexible data container that can hold a dynamic number of elements.

    Two essential operations that stacks support:

        1. pushing elements onto the top of the stack
        2. popping elements off the top of the stack

    Stacks are a last-in, first-out data structure.


Call Stacks and Exception Handling

    Runtime seeks the closest exception handler to the thrown exception.
    
    If no matching handler exists in the current stack frame, the runtime will unwind the call stack until a suitable handler is found.
    
    Objects whose lifetimes are ended get destroyed in the usual way.


Throwing in Destructors

    Not the wisest of ideas.

    Exceptions thrown in a destructor MUST be caught within the destructor.

<stdexcept>
source: https://en.cppreference.com/w/cpp/header/stdexcept

    This header is part of the error handling library.

source: https://cplusplus.com/reference/stdexcept/

    This header defines a set of standard exceptions that both the library and programs can use to report common errors.

    They are divided in two sets:

        Classes
        1. Logic Errors
            logic_error, Logic error exception.
            domain_error, Domain error exception.
            invalid_argument, Invalid argument exception.
            length_error, Length error exception.
            out_of_range, Out of range error exception.

        2. Runtime Errors
            runtime_error, Runtime error exception.
            range_error, Range error exception.
            overflow_error, Overflow error exception.
            underflow_error, Underflow error exception.

GENERAL RULE: Treat all destrutors as sif they are noexcept.


SimpleString Class
==================

    RAII: Resource Acquisition is Initialization.

    CADRe: Constructor acquires, destructor releases.


    Description:
    ------------

    The example shows how constructors, destructors, members, exceptions work together.

    simplestring.cpp adds C-style strings together and then print the result.

    A class enclosing a SimpleString as a member must have the string fully constructed and class invariants established before it can complete.


    String Copy Function
    --------------------

    strncpy(char* destination, const char* source, std::size_t num);

    - Copies num bytes fro source into destination.
    - Upon completion returns destination (which you then discard).
    - Finish by adding a newline character \n and a null byte to the end of the buffer.
    - Return true to indicate successfull appendixing.


Exceptions and Performance
==========================

    Errors are unavoidable, but if exceptions are used correctly and no errors occur, the program is faster than manually error-checked code.

    Exception handling can sometimes be slower if an error does occur, but the program gains robustness and maintainability.


Embedded Contexts
=================

You will be without exceptions when developing for embedded systems!

    Alternatives:

    1. Manually enforce class invariants by exposing a method that communicates whether the class invariants could be established.

    2. Strucutred binding declaration
    
        Language feature allowing you to return multiple values from a function call. Use this to return success flags alongside return value.


Copy Semantics
==============

Extremely common, especially when pasing objects to functions by value.

Member-wise copy: Passing by value will cause *each member* to be copied into the parameter.

Double-free:
------------
    Occurs when you deallocate an object twice. Usually related to copy semantics errors.


Copying
=======

Two ways to copy an object:

    1. Copy Construction.

        Creates a copy and assigns it to a brand-new object.
        (Copy constructors get invoked when passing an object by value!)

    2. Copy Assignment.

        Create a copy of an object and assign it to another existing object.
        Ex: (b = a).

    Main difference between Copy Construction and Copy Assignment, is that in Copy Assignment, b might  already have a value, and b's resources must be cleaned up before copying a.


Default Copy
============

The compiler will often generate default implementations for copy construction and copy assignment.

The default implementation is to invoke copy construction or copy assignment on each of a class' members.

BE CAREFUL with default copy semantics, they're likely wrong.

    Default keyword
    ---------------

        Explicitly declare that default copy assignment and copy construction are acceptable for such classes using the default keyword.

Any class that owns a resource (printer, network connection, file) should have an explicitly defined Copy Assignment operator and Copy Constructor.


Copy Guidelines
===============

Consider the following criteria before implementing copy behaviour:

    Correctness
    -----------
    Ensure that class invariants are maintained.
    The Copy Constructor can violate invariants.

    Independence
    ------------
    After copy asignment or construction, the original object and the copy should not be able to change each other's state during modifictation.

    Equivalence
    -----------
    The original and copy should be the same. This can depend on context. An operation applied to the original should yield the same result when applied to the copy.


Move Semantics
==============

Copying can be time-consuming at runtime, especially when large amounts of data are involved. In this case, you may just want to transfer ownership of resources from one object to another. You can make a copy and destroy the original, but this is inefficient. This is when you would prefer to perform a "move".

You can perform only two operations on a moved-from object:
    
    1. Re-assign.
    2. Destruct.

Just like with Copy Semantics, with Move Semantics you will be moving objects with Move Constructors and Move Assignment Operators.


Value Categories
================

Every expression has TWO important characteristics:

    1. Type.
    2. Value Category.

What are the categories?

    Generalized lvalue      -->     glvalue
    Pure rvalue             -->     prvalue
    Expiring value          -->     xvalue

To get a grasp on Move Semantics, just focus on lvalues and rvalues.

lvalue: Any value that has a name.
rvalue: Is anything that isn't an lvalue.


lvalue and rvalue References
============================

Tell the compiler that a function accepts lvalues or rvalues using lvalue references and rvalue references.

    lvalue reference: &
    rvalue reference: &&

The compiler does a good job of determining whether an object is an lvalue or an rvalue.


std::move Function
==================

An lvalue reference can be cast to an rvalue reference using the std::move function from the <utility> header.

Use caution with std::move, it removes the safeguards keeping you from interacting with a moved-from object.

If an lvalue is at hand, moving is suppressed, if an rvalue is at hand, moving is enabled.
