Part 1 Chapter 6: COMPILE-TIME POLYMORPHISM
===========================================

    Compile-time polymorphism with templates.
    Declare and use templates.
    Enforce type safety.
    Survey some of the templates more advanced usages.
    Comparison of runtime and compile-time polymorphism in C++.


Templates
=========

    Compile-time polymorphism is achieved in C++ through templates.
    
    What is a template?
    -------------------
        - Class or function with template parameters.
        - Params can stand in for any type.
        - Compiler will stamp out a bespoke template instantiation when a template is used with a type.


    What is Template Instantiation?
    -------------------------------
        - The Process of creating a class or a function from a template.
        - Template instantiations are sometimes called concrete classes and conrete types.
    
    What are templates for?
    -----------------------
        - Instead of having redundant code, a single template may be written. The compiler then generates new template instances whenever a new combination of types in the template parameters is encountered.


Declaring Templates
===================

    How are templates declared?
    ---------------------------
        - With a template prefix consisting of the word "template" wrapped in angle brackets <>.
        - One or more template paramters are placed inside the angle brackets.
        - Parameters are declared using either the typename or class keywords followed by an identifier.
        - template<typename T> declares that the template takes a template parameter T.


Template Class Definitions
==========================

    Example:
        ```
        template<typename X, typename Y,, typename Z>
        struct MytemplateClass {
            X foo(Y&);
        private:
            Z* member;
        }
        ```

    Description:
        - "template" keyword begins the template prefix.
        - Declarations of one or more template parameters go inside the angle brackets.
        - "typename" or "class" keywords are interchangable for declarig template parameters, followed by an identifier.
        - Within MyTemplateClass, x, y, and z are used as if they were any fully specified type such as int or a user-defined class.
        - The foo method takes a Y reference, returns an X.
        - Members can be declared that include template parameters, such as a pointer to Z as in the example.
        - Apart from the prefix beginning, this template class is almost identical to a non-template class.

Template Function Definitions
-----------------------------
    Template functions can be specified, and they can take template parameters. (Listing 6_2.cpp)

Instantiating Templates
-----------------------
    How do you instantiate a template class?

        ```
        tc_name<t_param1, t_param2, ...>my_concrete_class{ ... };
        ```

    Description:
        - tc_name: Template class' name.
        - t_param1, t_param2: Template parameters.
        - Use any initialization syntax you prefer as if it were a normal type.
    
    Instantiating a Template Function is similar:

        ```
        auto result = tf_name<t_param1, t_param2, ...>(f_param1, f_param2, ...);
        ```

        - tf_name: Template Function's name.
        - Fill in params as if it were a normal type.
        - Template function instantiation invoked with parentheses and function parameters. 


Named Conversion Functions
==========================
    What are they?
    Language features that explicitly convert one type into another type.

    When are they used?
    Sparingly, in situations where implicit conversions or constructors cannot get the types that are required.

    How do they work?
    Accepting a single object parameter, the object that is to be cast, and a single type parameter (the parameter you are casting to).

    Modifying a const object:
        - const_cast required to cast away "const" qualifier.
    
    Similarity to Template Functions:
    Conceptually very close, but technically not Template Functions.

    const_cast
    ----------
    Removes const modifier so that const values can be modified.

    ```
    // Listing 6-3

    // encased_solo parameter is a const reference, any attempt to modify it would result in a compiler error. However, by using const_cast, we can remove the const qualifier and modify the value.

    #include <cstdio>

    void carbon_thaw(const int& encased_solo) {
    // encased_solo++; // error: increment of read-only reference 

    // Use const_cast to remove the const qualifier and modify the value:
    auto& hibernation_sick_solo = const_cast<int&>(encased_solo);
    hibernation_sick_solo++;
    }
    ```

    static_cast
    -----------
    Reverses a well-defined implicit conversion, for example: An integer type to another integer type.

    The object-to-cast is of some type that the desired-type implicitly converts to.

    Why might you need static_cast?
    Implicit casts generally are not reversible.

    ```
    // This program defines an increment_as_short function that takes a void pointer, casts it to a short pointer, increments the value it points to, and returns the incremented value. The main function initializes a short variable with the value 665, calls the increment_as_short function with its address, and prints the result.

    // Some low-level applications might require you to interpret raw bytes as an integer type

    #include <cstdio>

    // target parameter is a void pointer.
    short increment_as_short(void* target) {
    // Use static_cast to convert the void pointer to a short pointer, then dereference it to get the value, increment it, and return the result.
    auto as_short = static_cast<short*>(target);
    *as_short = *as_short + 1;
    return *as_short;
    }

    int main() {
    short beast{ 665 };
    auto mark_of_the_beast = increment_as_short(&beast);
    printf("%d is the mark_of_the_beast.", mark_of_the_beast);
    }

    // The implicit conversion of short* to void* is well defined. Attempting ill-defined conversions with static_cast, such as converting char* to a float* will result in a compile-time error.
    ```
