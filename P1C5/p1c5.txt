Part 1 Chapter 5: RUNTIME POLYMORPHISM
--------------------------------------

    Polymorphism

    Code that can be reused with different types.
    Loosely coupled, highly reusable.
    Makes code more maintainable and readable.


    Two polymorphic approaches:

    Compile-time polymorphic code.
        Incorporates polymorphic types you can determine at compile time.

    Runtime polymorphism.
        Incorporates types determined at runtime.

    Adding New loggers

    5-2 suffers several design problems:

        1. You need to write a new logger type.
        2. You need to add a new enum value to the enum class LoggerType.
        3. You must add a new case in the switch statement.
        4. You must add the new logging class as a member to Bank.
    
    An alternative approach is one where Bank holds a pointer to a logger: Then the pointer can be set directyl, and you can get rid of LoggerType entirely.
    
        Expoloits the fact that loggers have the same function prototype.

        Bank class doesn't need to know the implementation details of the Logger reference it holds, just how to invoke its methods.
    
    Interfaces

        An interface is a shared boundary that contains no data or code.
        Definese function signatures that all implementations of the interface agree to supprot.
        Code or data that declares support for an interface.
        A contract between classes that implement the interface and users of the class.
        "Consumer" never needs to know the underlying implementation. (Listing 5-1 Bank is a consumer of ConsoleLogger).
        Interfaces impose stringent requirements.
        Consumer of an interface can use only the methods explicitly defined in the interface.
        Bank class is not required to know anything about how ConsoleLogger performs its function, just how to call log_transfer.

        Interfaces are promote highly reusable and loosely coupled code.