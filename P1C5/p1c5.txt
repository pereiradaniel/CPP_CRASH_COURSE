Part 1 Chapter 5: RUNTIME POLYMORPHISM
--------------------------------------

    Polymorphism

    Code that can be reused with different types.
    Loosely coupled, highly reusable.
    Makes code more maintainable and readable.


    Two polymorphic approaches:

    Compile-time polymorphic code.
        Incorporates polymorphic types you can determine at compile time.

    Runtime polymorphism.
        Incorporates types determined at runtime.

    Adding New loggers

    5-2 suffers several design problems:

        1. You need to write a new logger type.
        2. You need to add a new enum value to the enum class LoggerType.
        3. You must add a new case in the switch statement.
        4. You must add the new logging class as a member to Bank.
    
    An alternative approach is one where Bank holds a pointer to a logger: Then the pointer can be set directyl, and you can get rid of LoggerType entirely.
    
        Expoloits the fact that loggers have the same function prototype.

        Bank class doesn't need to know the implementation details of the Logger reference it holds, just how to invoke its methods.
    
    
    Interfaces

        An interface is a shared boundary that contains no data or code.
        Definese function signatures that all implementations of the interface agree to supprot.
        Code or data that declares support for an interface.
        A contract between classes that implement the interface and users of the class.
        "Consumer" never needs to know the underlying implementation. (Listing 5-1 Bank is a consumer of ConsoleLogger).
        Interfaces impose stringent requirements.
        Consumer of an interface can use only the methods explicitly defined in the interface.
        Bank class is not required to know anything about how ConsoleLogger performs its function, just how to call log_transfer.

        Interfaces are promote highly reusable and loosely coupled code.
    

    Object Composition and Implementation Inheritance

        Design pattern where a class contains members of other class types.
        
        Implementation inheritance:
            - Anitquated design pattern that achieves runtime polymorphism.
            - Builds hierarchies of classes; each child inherits functionality from its parents.
            - Found in legacy code.
            - The way C++ interfaces has a shared lineage with implementation inheritance.
        

    Defining Interfaces

        There is no interface keywords in C++.
        Interfaces are defined using antiquated inheritance mechanisms.
        Listing 5-3: A fully specified Logger interface and corresponding ConsoleLogger implementing that interface.
    

    Base Class Inheritance

        Derived classes declared using following syntax:

        ```
        struct DerivedClass : BaseClass {
            --snip--
        }
        ```

        ```
        // Listing 5-4: A program using a derived class in place of a base class.

        struct BaseClass {};
        struct DerivedClass : BaseClass{};          // DerivedClass derives from BaseClass.
        void are_belong_to_us(BaseClass& base) {}   // Takes reference to BaseClass argumnt 'base'.

        int main() {
            DerivedClass derived;
            are_belong_to_us(derived);                 // Can be invoked with an instance of Derived class. 
        }
        ```
    
        ```
        // Listing 5-5: This program attempts to use a bse classin place of a derived class. (This listing won't compile.)

        struct BaseClass {};
        struct DerivedClass : BaseClass {};             // BaseClass does't derive from DerivedClass.
        void all_about_that(DerivedClass& derived) {}   // Function taks DerivedClass argument.

        int main() {
        BaseClass base;
        all_about_that(base);                         // Invoking function yields compiler error.
        }
        ```